[
["index.html", "Python packages Chapter 1 Preface", " Python packages Tiffany Timbers &amp; Tomas Beuzen 2020-02-19 Chapter 1 Preface This book is aimed at Python intermediate users who want to package up their code to share it with their collaborators (including their future selves) and the wider Python community. It‚Äôs scope and intent is inspired by the R packages book written by Hadley Wickham and Jenny Bryan. "],
["setup.html", "Chapter 2 System setup 2.1 Installing and updating Python 2.2 Register for a PyPI account 2.3 Setting up the RStudio IDE with Python 2.4 Alternative Python IDEs", " Chapter 2 System setup 2.1 Installing and updating Python In order to start off on a good footing, we recommend you follow these system set-up instructions so you will run into fewer technical issues (compared to not using the same system this book was designed for). We recommend installing Python 3.7 via the Anaconda distribution, following the instructions here: https://docs.anaconda.com/anaconda/install/. If you already have installed this distribution, ensure Python, and the conda package manager is up to date by running the following commands: $ conda update --all Next, use conda to install Python poetry - a python package that will help us more efficiently build our Python packages: $ conda install -c conda-forge poetry Finally, we install cookiecutter - a python package that will create Python projects from project templates $ conda install -c conda-forge cookiecutter 2.2 Register for a PyPI account To publish a Python package on PyPI to share with others, you will need to register for a PyPI account. You can do so freely by clicking here: https://pypi.org/account/register/ Before we are ready to publish our packages on PyPI, it is advisable that we test drive them on TestPyPI first. To do so, you need to also register for a TestPyPI account. You can do so freely by clicking here: https://test.pypi.org/account/register/ 2.3 Setting up the RStudio IDE with Python This book will use the RStudio integrated development environment (IDE) to develop Python packages - we use RStudio because in the UBC Master of Data Science program we teach both the R and Python programming languages and prefer to use an IDE that works well with both. However, any other Python IDE should work and we briefly describe some in Alternative Python IDEs. If you would like to use the RStudio IDE we recommend installing the most recent version of the IDE from the preview site: https://rstudio.com/products/rstudio/download/preview/ and then installing R from CRAN, and the reticulate R package via install.packages(\"reticulate\") from the R console inside RStudio. When installing reticulate, you will be prompted to install miniconda, if you have already installed the Anaconda distribution of Python, answer ‚Äúno‚Äù to installing miniconda at this prompt. 2.3.1 Find where Anaconda is installed on your machine 2.3.1.1 Mac OS &amp; Linux In terminal, type: which Python 2.3.1.2 Windows In the Anaconda Prompt type: where python. 2.3.2 Configuring reticulate for to use the Python REPL inside RStudio Create a file named .Rprofile in your $HOME directory that contains the following: Sys.setenv(RETICULATE_PYTHON = &quot;path_to_the_folder_containing_anaconda&#39;s_python&quot;) For me the \"path_to_the_folder_containing_anaconda's_python\" was 'Users/user1/anaconda3/bin/Python' on a Mac OS. Restart RStudio for this to take effect. 2.3.3 Configuring the RStudio terminal 2.3.3.1 Mac OS &amp; Linux Open (or create) the file called .bash_profile in your $HOME directory and add the following to the last line of that file: export PATH=&quot;path_to_the_folder_containing_anaconda&#39;s_python:$PATH&quot; For me that line is export PATH=\"//anaconda3/bin:$PATH\". Restart RStudio for this to take effect. 2.3.3.2 Windows The default terminal in RStudio on Windows is PowerShell. This causes some unexpected problems as its not a true bash shell. You should change this using the following menu selections inside RStudio: Global Options -&gt; Terminal -&gt; Shell -&gt; Git Bash 2.4 Alternative Python IDEs Commonly used free Python IDEs include Visual Studio Code, Atom, and PyCharm Community Edition. Visual Studio Code and Atom are text editors that can be customised with extensions to act as Python (or any other language) IDEs. In contrast, PyCharm is specifically a Python IDE and will work right out of the box - we describe setting up PyCharm briefly below. 2.4.1 PyCharm PyCharm offers a paid Professional version and free Community version. You can download either from https://www.jetbrains.com/pycharm/download/. Once downloaded, PyCharm will guide you through initial setup. We recommended using all default settings throughout the setup, with the exception of installing the Markdown Plugin when prompted to install ‚ÄúFeatured Plugins‚Äù. Once setup is complete you should see something like the following screenshot: We now need to link Anaconda with PyCharm. Click Configure at the bottom right of the screen and then Preferences. Select Project Interpreter from the tab-menu and then click the gear icon to the right of the drop-down menu that appears and select Add‚Ä¶. In the pop-up menu that appears, click System Interpreter from the tab-menu and click the three dots ‚Ä¶ to the right of the drop-down menu. You now need to provide the path to Anaconda‚Äôs installation of Python, something like ‚Äú/Users/user/anaconda3/bin/python‚Äù. You can determine the path using the following: Mac OS &amp; Linux: In terminal, type: which Python Windows: In the Anaconda Prompt type: where python. Copy and paste the path into the PyCharm pop-up. At this point, your window will probably look something like the one below. Click OK. Click OK again to get back to the Preferences menu, at which point PyCharm will show Anaconda‚Äôs installation of Python in the Project Interpreter drop-down menu and will populate the screen with the packages available to that interpreter (these will be all the packages installed in your base Anaconda environment) Click OK to return to the main menu. To start a new project you will click Create New Project. In the subsequent screen, an example of which is shown below, you may choose a location for your new project and you can also select an interpreter. Choose the Existing Interpreter radio button and then from the drop-down menu select Anaconda‚Äôs Python interpreter that we just set-up (this will likely be the only option in the drop-down menu). Click Create to get started. Note that PyCharm has excellent integration with Conda environments. If you wish to use a custom Conda environment for a project, you can easily create or select an existing environment to use as a project‚Äôs interpreter. To do this, in Step 3 above, simply click Conda Environment rather than System Interpreter and create or select an existing Conda environment. This environment will then be available to select as a project interpreter for new or existing projects. This was a brief, practical guide to getting started with PyCharm Community Edition. We recommend checking out the documentation for more guidance on setting up and using PyCharm. "],
["whole-game.html", "Chapter 3 The Whole Game 3.1 Use Cookiecutter &amp; Poetry to create a Python project 3.2 Put your project under version control 3.3 Write the first function 3.4 Test drive your package code 3.5 Add package function dependencies", " Chapter 3 The Whole Game This chapter demonstrates how to develop an entire small toy Python package from beginning to end. It‚Äôs purpose it to motivate and give a high level overview of how a Python package can and should be developed. Later chapters will delve deeper into important package specifics. This chapter is a Pythonified version of the Whole Game chapter written by Jenny Bryan that can be found in the the R packages book. 3.1 Use Cookiecutter &amp; Poetry to create a Python project So that we do not have to create a complicated file and directory structure ourselves, we will use Cookiecutter &amp; Poetry to do this for us! First we start with using Cookiecutter to create the project file and directory structure for our Python project (which will be a Python package). We will use a simplified version of the template base by the PyOpenSci organization designed specifically for creating Python packages. PyOpenSci is a not-for-profit organization that promotes open and reproducible research through peer-review of scientific Python packages. To use Cookiecutter to set up the structure of your Python package, run the line of code below in the terminal from the directory where you would like your package to live. $ cookiecutter https://github.com/UBC-MDS/cookiecutter-ubc-mds.git You will be prompted to provide information that will help customize the project. Here is a example of how to respond the the prompts: full_name [Audrey Roy Greenfeld]: Tiffany Timbers email [audreyr@example.com]: tiffany.timbers@gmail.com github_username [audreyr]: ttimbers project_name [Python Boilerplate]: foocat project_slug [foocat]: foocat project_short_description [Python Boilerplate contains all the boilerplate you need to create a Python package.]: Python package that eases the pain concatenating Pandas categoricals! pypi_username [ttimbers]: version [&#39;0.1.0&#39;]: Select open_source_license: 1 - MIT license 2 - BSD license 3 - ISC license 4 - Apache Software License 2.0 5 - GNU General Public License v3 Choose from 1, 2, 3, 4, 5 [1]: 1 Next we navigate into the project directory we just created and initialize the project as a Poetry project so that we can take advantage of the package management and building tools provided by Poetry: $ cd foocat $ poetry init Again we are prompted for more information. We are provided with some suggestions for the information (which I think is gleaned from the Cookiecutter template that we just set up), and if we agree we can simply click enter at the prompt. Here is a example of how to respond the the prompts: This command will guide you through creating your pyproject.toml config. Package name [foocat]: Version [0.1.0]: Description []: Python package that eases the pain concatenating Pandas categoricals! Author [ttimbers &lt;tiffany.timbers@stat.ubc.ca&gt;, n to skip]: License []: MIT Compatible Python versions [^3.7]: Would you like to define your main dependencies interactively? (yes/no) [yes] no Would you like to define your dev dependencies (require-dev) interactively (yes/no) [yes] no Generated file [tool.poetry] name = &quot;foocat&quot; version = &quot;0.1.0&quot; description = &quot;Python package that eases the pain concatenating Pandas categoricals!&quot; authors = [&quot;ttimbers &lt;tiffany.timbers@stat.ubc.ca&gt;&quot;] license = &quot;MIT&quot; [tool.poetry.dependencies] python = &quot;^3.7&quot; [tool.poetry.dev-dependencies] [build-system] requires = [&quot;poetry&gt;=0.12&quot;] build-backend = &quot;poetry.masonry.api&quot; Do you confirm generation? (yes/no) [yes] Note - we said no to defining our dependencies interactively because it is more efficient to define them using poetry add at a later time point. After using Cookiecutter and Poetry, we end up with the following directory structure: foocat ‚îú‚îÄ‚îÄ CONDUCT.md ‚îú‚îÄ‚îÄ CONTRIBUTING.md ‚îú‚îÄ‚îÄ CONTRIBUTORS.md ‚îú‚îÄ‚îÄ docs ‚îÇ ‚îî‚îÄ‚îÄ conf.py ‚îÇ ‚îî‚îÄ‚îÄ contributing.rst ‚îÇ ‚îî‚îÄ‚îÄ contributors.rst ‚îÇ ‚îî‚îÄ‚îÄ index.rst ‚îÇ ‚îî‚îÄ‚îÄ installation.rst ‚îÇ ‚îî‚îÄ‚îÄ Makefile ‚îÇ ‚îî‚îÄ‚îÄ readme.rst ‚îÇ ‚îî‚îÄ‚îÄ usage.rst ‚îú‚îÄ‚îÄ foocat ‚îÇ ‚îî‚îÄ‚îÄ __init__.py ‚îÇ ‚îî‚îÄ‚îÄ foocat.py ‚îú‚îÄ‚îÄ .github ‚îÇ ‚îî‚îÄ‚îÄ workflows ‚îÇ ‚îî‚îÄ‚îÄ build.yml ‚îÇ ‚îî‚îÄ‚îÄ release.yml ‚îú‚îÄ‚îÄ .gitignore ‚îú‚îÄ‚îÄ LICENSE ‚îú‚îÄ‚îÄ pyproject.toml ‚îî‚îÄ‚îÄ tests ‚îú‚îÄ‚îÄ __init__.py ‚îî‚îÄ‚îÄ test_foocat.py It gives us a boilerplate file and directory structure suitable for building a Python package. It indeed looks like a lot, however, at this point we need only to worry about a few of these files and directories to get a working package together, specifically a file for us to write out Python functions that our package will distribute (foocat/foocat.py), a home for our tests to ensure that our package functions work as we expect they should (tests/test_foocat.py), as well as a pyproject.toml file that we will use to define our project‚Äôs metadata and dependencies. We will focus on these in this chapter. Later chapters will focus on the rest, whose aim is to make your package one of high quality (in respect to documentation, continuous integration testing, and version bumping). Optional for RStudio IDE users Users of the RStudio IDE may also want to make this Python project directory an RStudio project. Why might you ask? Well, once you have an *.Rproj file, you can use that file to quickly open the RStudio IDE (which has a terminal and an interactive Python REPL, assuming you have set this up with reticulate) to the project‚Äôs root directory. 3.2 Put your project under version control It is in our opinion that every data science project should put under local and remote version control. The tools we recommend using for this are Git &amp; GitHub. For this book, we assume Git is installed on their machine, have novice Git skills, and that users have a GitHub.com account. 3.2.1 Set-up local version control From the terminal and in the root of this project directory, initialize the repository to be tracked by Git: $ git init Initialized empty Git repository in /Users/tiffany/Documents/ubc-mds/foocat/.git/ Next, tell Git which files to track (all of them at this point) and commit these changes locally: $ git add . $ git commit -m &quot;initial project set-up&quot; [master (root-commit) ca03932] initial project set-up 22 files changed, 798 insertions(+) create mode 100644 .github/workflows/build.yml create mode 100644 .github/workflows/release.yml create mode 100644 .gitignore create mode 100644 CONDUCT.md create mode 100755 CONTRIBUTING.md create mode 100755 CONTRIBUTORS.md create mode 100755 LICENSE create mode 100644 README.md create mode 100755 docs/Makefile create mode 100755 docs/conf.py create mode 100755 docs/contributing.rst create mode 100755 docs/contributors.rst create mode 100755 docs/index.rst create mode 100755 docs/installation.rst create mode 100755 docs/make.bat create mode 100755 docs/readme.rst create mode 100755 docs/usage.rst create mode 100644 foocat/__init__.py create mode 100644 foocat/foocat.py create mode 100644 pyproject.toml create mode 100644 tests/__init__.py create mode 100644 tests/test_foocat.py 3.2.2 Set-up remote version control Now that we have set up our local version control, let‚Äôs create a repository on GitHub.com and set that as the remote version control home for this project: The options we recommend for setting up a repository for a Python package using the workflow we present in this book include: give the GitHub.com repository the same name as your Python Poetry project‚Äôs name make the GitHub.com repository public do not initialize the GitHub.com repository with a README Next, we set-up the remote address locally, and push our project to GitHub.com: $ git remote add origin git@github.com:ttimbers/foocat.git $ git push -u origin master Note: the example above uses SSH authentication with GitHub, HTTPS authentication works as well and would use this url in place of the one shown above to set the remote: https://github.com/ttimbers/foocat.git. 3.3 Write the first function Pandas categoricals are a very useful data type for modeling (and were inspired by R‚Äôs factors), but certain manipulations of this data type can be tricky in data wrangling. One such challenge is concatenation of Pandas categoricals. Let‚Äôs observe the result of trying to concatenate two Pandas categoricals objects: &gt;&gt;&gt; import pandas as pd &gt;&gt;&gt; a = pd.Categorical([&quot;character&quot;, &quot;hits&quot;, &quot;your&quot;, &quot;eyeballs&quot;]) &gt;&gt;&gt; b = pd.Categorical([&quot;but&quot;, &quot;integer&quot;, &quot;where it&quot;, &quot;counts&quot;]) &gt;&gt;&gt; pd.concat([a, b]) ## Error in py_call_impl(callable, dots$args, dots$keywords): TypeError: cannot concatenate object of type &#39;&lt;class &#39;pandas.core.arrays.categorical.Categorical&#39;&gt;&#39;; only Series and DataFrame objs are valid This occurs because the categoricals are represented as integers in memory, and in a the integer 0 corresponds to the word ‚Äúcharacter‚Äù while in b, the integer 0 corresponds to the word ‚Äúbut‚Äù. Thus, when we ask Python to concatenate these two Pandas categorical options it doesn‚Äôt know what to do with these integer mappings to different categories, and so it throws an error. We can get around this several ways, one way is to convert the Pandas categoricals to a str type, then do the concatenation, and finally convert the concatenated Pandas obeject to a categorical again. We demonstrate that approach below: &gt;&gt;&gt; concatenated = pd.concat([pd.Series(a.astype(&quot;str&quot;)), pd.Series(b.astype(&quot;str&quot;))]) &gt;&gt;&gt; pd.Categorical(concatenated) ## [character, hits, your, eyeballs, but, integer, where it, counts] ## Categories (8, object): [but, character, counts, eyeballs, hits, integer, where it, your] That seems to work üéâ, but its quite a bit of typing every time we want to do this‚Ä¶ Let‚Äôs turn this into a function called catbind! def catbind(a, b): concatenated = pd.concat([pd.Series(a.astype(&quot;str&quot;)), pd.Series(b.astype(&quot;str&quot;))]) return pd.Categorical(concatenated) catbind(a, b) ## [character, hits, your, eyeballs, but, integer, where it, counts] ## Categories (8, object): [but, character, counts, eyeballs, hits, integer, where it, your] Note - this book assumes you know how to write, document and test functions in Python. To learn more about this see Think Python, Chapter 3: Functions by Allen Downey. Where do we save this function if we want it to be a part of our foocat Python package? Let‚Äôs review the landscape of our Python project so far: foocat ‚îú‚îÄ‚îÄ CONDUCT.md ‚îú‚îÄ‚îÄ CONTRIBUTING.md ‚îú‚îÄ‚îÄ CONTRIBUTORS.md ‚îú‚îÄ‚îÄ docs ‚îÇ ‚îî‚îÄ‚îÄ conf.py ‚îÇ ‚îî‚îÄ‚îÄ contributing.rst ‚îÇ ‚îî‚îÄ‚îÄ contributors.rst ‚îÇ ‚îî‚îÄ‚îÄ index.rst ‚îÇ ‚îî‚îÄ‚îÄ installation.rst ‚îÇ ‚îî‚îÄ‚îÄ Makefile ‚îÇ ‚îî‚îÄ‚îÄ readme.rst ‚îÇ ‚îî‚îÄ‚îÄ usage.rst ‚îú‚îÄ‚îÄ foocat ‚îÇ ‚îî‚îÄ‚îÄ __init__.py ‚îÇ ‚îî‚îÄ‚îÄ foocat.py ‚îú‚îÄ‚îÄ .github ‚îÇ ‚îî‚îÄ‚îÄ workflows ‚îÇ ‚îî‚îÄ‚îÄ build.yml ‚îÇ ‚îî‚îÄ‚îÄ release.yml ‚îú‚îÄ‚îÄ .gitignore ‚îú‚îÄ‚îÄ LICENSE ‚îú‚îÄ‚îÄ pyproject.toml ‚îî‚îÄ‚îÄ tests ‚îú‚îÄ‚îÄ __init__.py ‚îî‚îÄ‚îÄ test_foocat.py All the code that we would like the user to run as part of our package should live inside the foocat directory. Typically, with a relatively small package with just a few functions, we would house them inside a single python script inside this directory. Our template project directory structure already created and named such a place for us, foocat/foocat.py. Let‚Äôs save our function there. Additionally, given that our package depends on the Pandas Python package, we should import Pandas at the top of the foocat.py file. Here‚Äôs what foocat.py should now look like: import pandas as pd def catbind(a, b): concatenated = pd.concat([pd.Series(a.astype(&quot;str&quot;)), pd.Series(b.astype(&quot;str&quot;))]) return pd.Categorical(concatenated) 3.4 Test drive your package code To test drive the function we just wrote we first install the package locally using Python poetry. We choose to do this with Python poetry as opposed to using pip because poetry automatically creates a virtual environment for us and will perform tricky tasks like package solving that can sometimes trip us up when we use pip alone. $ poetry install Creating virtualenv foocat-z0_J6H1I-py3.7 in /Users/tiffany/Library/Caches/pypoetry/virtualenvs Installing dependencies from lock file No dependencies to install or update - Installing foocat (0.1.0) Now, inside this project directory, we can open an interactive Python session and import our function as shown: &gt;&gt;&gt; from foocat import foocat By doing this we can access the the function in our Python session via foocat.catbind. Let‚Äôs now try to use this function to concatenate two Pandas categoricals: &gt;&gt;&gt; import pandas as pd &gt;&gt;&gt; a = pd.Categorical([&quot;character&quot;, &quot;hits&quot;, &quot;your&quot;, &quot;eyeballs&quot;]) &gt;&gt;&gt; b = pd.Categorical([&quot;but&quot;, &quot;integer&quot;, &quot;where it&quot;, &quot;counts&quot;]) &gt;&gt;&gt; foocat.catbind(a, b) [character, hits, your, eyeballs, but, integer, where it, counts] Categories (8, object): [but, character, counts, eyeballs, hits, integer, where it, your] Hurray again! This seems to work as expected! 3.5 Add package function dependencies Our function depends on the pandas package, and without it, it would fail to work. Thus we need to record this dependency in a useful place so that when we publish our pacakged code this important information (and the mechanism for making it work) will be shipped along with it. We again use poetry to do this, using the add command. This command will update the [tool.poetry.dependencies] section of the pyproject.toml file which currently looks like this and lists only Python as a project dependency: [tool.poetry] name = &quot;foocat&quot; version = &quot;0.1.0&quot; description = &quot;Python package that eases the pain concatenating Pandas categoricals!&quot; authors = [&quot;ttimbers &lt;tiffany.timbers@stat.ubc.ca&gt;&quot;] license = &quot;MIT&quot; [tool.poetry.dependencies] python = &quot;^3.7&quot; [tool.poetry.dev-dependencies] [build-system] requires = [&quot;poetry&gt;=0.12&quot;] build-backend = &quot;poetry.masonry.api&quot; Let‚Äôs add our pandas dependency now: $ poetry add pandas Using version ^1.0.1 for pandas Updating dependencies Resolving dependencies... (0.1s) Writing lock file Package operations: 4 installs, 1 update, 0 removals - Updating six (1.14.0 /usr/local/Cellar/poetry/1.0.3/libexec/vendor/lib/python3.7/site-packages -&gt; 1.14.0) - Installing numpy (1.18.1) - Installing python-dateutil (2.8.1) - Installing pytz (2019.3) - Installing pandas (1.0.1) Now if we view our pyproject.toml file we see that pandas is now listed as a dependency: [tool.poetry] name = &quot;foocat&quot; version = &quot;0.1.0&quot; description = &quot;Python package that eases the pain concatenating Pandas categoricals!&quot; authors = [&quot;ttimbers &lt;tiffany.timbers@stat.ubc.ca&gt;&quot;] license = &quot;MIT&quot; [tool.poetry.dependencies] python = &quot;^3.7&quot; pandas = &quot;^1.0.1&quot; [tool.poetry.dev-dependencies] [build-system] requires = [&quot;poetry&gt;=0.12&quot;] build-backend = &quot;poetry.masonry.api&quot; "],
["package-structure.html", "Chapter 4 Package structure and state 4.1 Package states 4.2 Modules 4.3 Source packages 4.4 Binary packages 4.5 Installed packages 4.6 Libraries", " Chapter 4 Package structure and state The previous chapter gave a high level overview of how a Python package can be developed. This chapter now takes a more detailed look at Python‚Äôs range of packaging options. You‚Äôll learn about the various different kinds of Python package states and why these are important. Often, people don‚Äôt think about packaging until their code is actually written - but we‚Äôll learn that thinking about packaging before even creating your package can be very useful! This chapter is a Pythonified version of the Package structure and state chapter written by Jenny Bryan that can be found in the R packages book. 4.1 Package states 4.2 Modules 4.3 Source packages 4.4 Binary packages 4.5 Installed packages 4.6 Libraries "]
]
